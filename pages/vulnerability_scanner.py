import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta

from utils.visualization import plot_vulnerability_heatmap

def show_vulnerability_scanner():
    """Display the vulnerability scanner page content"""
    
    # Get vulnerability data from session state
    vulnerability_data = st.session_state.vulnerability_data
    
    # Create tabs for different vulnerability views
    tab1, tab2, tab3 = st.tabs(["Vulnerability Dashboard", "Scan Results", "Remediation Tracking"])
    
    with tab1:
        st.subheader("Vulnerability Overview")
        
        # Summary metrics in columns
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            critical_count = sum(vulnerability_data['severity'] == 'Critical')
            st.metric(
                label="Critical Vulnerabilities",
                value=critical_count,
                delta="-2" if critical_count > 2 else "0",
                delta_color="inverse"
            )
            
        with col2:
            high_count = sum(vulnerability_data['severity'] == 'High')
            st.metric(
                label="High Vulnerabilities",
                value=high_count,
                delta="-5" if high_count > 5 else "0",
                delta_color="inverse"
            )
            
        with col3:
            avg_risk = round(vulnerability_data['risk_score'].mean(), 1)
            st.metric(
                label="Average Risk Score",
                value=avg_risk,
                delta="-0.8" if avg_risk > 6 else "0",
                delta_color="inverse"
            )
            
        with col4:
            last_scan = datetime.now().strftime("%Y-%m-%d")
            st.metric(
                label="Last Full Scan",
                value=last_scan,
                delta="Today"
            )
        
        # Vulnerability heatmap
        st.plotly_chart(plot_vulnerability_heatmap(vulnerability_data), use_container_width=True)
        
        # Clean severity column for the bar chart only
        severity_data = vulnerability_data.copy()
        severity_data['severity'] = severity_data['severity'].fillna('').astype(str).str.strip()
        valid_severities = ['Critical', 'High', 'Medium', 'Low']
        severity_data = severity_data[severity_data['severity'].isin(valid_severities)]
        # Distribution of vulnerabilities by severity
        severity_counts = severity_data['severity'].value_counts().reindex(valid_severities, fill_value=0).reset_index()
        severity_counts.columns = ['severity', 'count']
        severity_counts = severity_counts[severity_counts['count'] > 0]
        if not severity_counts.empty:
            color_map = {
                'Critical': '#d7191c',
                'High': '#fdae61',
                'Medium': '#ffffbf',
                'Low': '#abd9e9'
            }
            fig = px.bar(
                severity_counts,
                x='severity',
                y='count',
                color='severity',
                color_discrete_map=color_map,
                title="Vulnerability Distribution by Severity",
                text='count'
            )
            fig.update_layout(
                xaxis_title="Severity",
                yaxis_title="Number of Vulnerabilities",
                showlegend=False,
                height=350
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.warning("No valid vulnerability severity data to display.")
    
    with tab2:
        st.subheader("Vulnerability Scan Results")
        
        # Filter options
        col1, col2, col3 = st.columns(3)
        
        with col1:
            severity_filter = st.multiselect(
                "Filter by Severity",
                options=["Critical", "High", "Medium", "Low"],
                default=["Critical", "High"]
            )
        
        with col2:
            system_filter = st.multiselect(
                "Filter by System",
                options=sorted(vulnerability_data["affected_systems"].unique()),
                default=None
            )
            
        with col3:
            search_filter = st.text_input("Search by name or CVE", "")
        
        # Apply filters
        filtered_vulns = vulnerability_data.copy()
        
        if severity_filter:
            filtered_vulns = filtered_vulns[filtered_vulns["severity"].isin(severity_filter)]
            
        if system_filter:
            filtered_vulns = filtered_vulns[filtered_vulns["affected_systems"].isin(system_filter)]
            
        if search_filter:
            search_lower = search_filter.lower()
            filtered_vulns = filtered_vulns[
                filtered_vulns["name"].str.lower().str.contains(search_lower) | 
                filtered_vulns["cve_id"].str.lower().str.contains(search_lower)
            ]
        
        # Sort by risk score (descending)
        filtered_vulns = filtered_vulns.sort_values("risk_score", ascending=False)
        
        # Display filtered vulnerabilities
        if not filtered_vulns.empty:
            st.write(f"Showing {len(filtered_vulns)} vulnerabilities")
            
            # Display as expandable sections
            for _, vuln in filtered_vulns.iterrows():
                # Create a color indicator based on severity
                severity_colors = {
                    'Critical': 'red',
                    'High': 'orange',
                    'Medium': 'yellow',
                    'Low': 'blue'
                }
                severity_color = severity_colors.get(vuln['severity'], 'gray')
                
                # Display vulnerability with expandable details
                with st.expander(f"{vuln['name']} - {vuln['cve_id']} [{vuln['severity']}]"):
                    col1, col2 = st.columns([1, 2])
                    
                    with col1:
                        st.markdown(f"**Severity:** <span style='color:{severity_color}'>{vuln['severity']}</span>", unsafe_allow_html=True)
                        st.markdown(f"**Risk Score:** {vuln['risk_score']}/10")
                        st.markdown(f"**Affected System:** {vuln['affected_systems']}")
                        st.markdown(f"**CVE ID:** [{vuln['cve_id']}](https://nvd.nist.gov/vuln/detail/{vuln['cve_id']})")
                    
                    with col2:
                        st.markdown("**Description:**")
                        st.write(vuln['description'])
                        
                        st.markdown("**Remediation:**")
                        st.write(vuln['remediation'])
        else:
            st.warning("No vulnerabilities match the selected filters.")
    
    with tab3:
        st.subheader("Remediation Tracking")
        
        # Generate some remediation status data
        remediation_data = []
        
        for _, vuln in vulnerability_data.iterrows():
            # Assign random remediation status for demo
            import random
            statuses = ['Not Started', 'In Progress', 'Scheduled', 'Mitigated', 'Resolved']
            status_weights = [0.1, 0.3, 0.2, 0.2, 0.2]
            
            # Higher severity items more likely to be addressed
            if vuln['severity'] == 'Critical':
                status_weights = [0.05, 0.35, 0.3, 0.2, 0.1]
            elif vuln['severity'] == 'High':
                status_weights = [0.1, 0.3, 0.3, 0.2, 0.1]
            
            status = random.choices(statuses, weights=status_weights)[0]
            assigned_to = random.choice(['Security Team', 'IT Operations', 'Development Team', 'Network Team', 'Unassigned'])
            
            # Calculate days overdue based on severity and status
            if status in ['Not Started', 'In Progress']:
                if vuln['severity'] == 'Critical':
                    days_overdue = random.randint(0, 10)
                elif vuln['severity'] == 'High':
                    days_overdue = random.randint(0, 20)
                else:
                    days_overdue = random.randint(0, 30)
            else:
                days_overdue = 0
            
            remediation_data.append({
                'id': vuln['id'],
                'name': vuln['name'],
                'cve_id': vuln['cve_id'],
                'severity': vuln['severity'],
                'affected_systems': vuln['affected_systems'],
                'status': status,
                'assigned_to': assigned_to,
                'days_overdue': days_overdue
            })
        
        remediation_df = pd.DataFrame(remediation_data)
        
        expected_columns = [
            'id', 'name', 'cve_id', 'severity', 'affected_systems',
            'status', 'assigned_to', 'days_overdue'
        ]
        for col in expected_columns:
            if col not in remediation_df.columns:
                remediation_df[col] = pd.Series(dtype='object')
        
        # Status distribution chart
        if not remediation_df.empty and 'status' in remediation_df.columns:
            status_counts = remediation_df['status'].value_counts().reset_index()
            status_counts.columns = ['status', 'count']
            fig = px.pie(
                status_counts,
                values='count',
                names='status',
                title="Remediation Status Overview",
                color='status',
                color_discrete_map={
                    'Not Started': '#d53e4f',
                    'In Progress': '#fc8d59',
                    'Scheduled': '#fee08b',
                    'Mitigated': '#e6f598',
                    'Resolved': '#99d594'
                }
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.warning("No remediation status data available to display.")
        
        # Overdue remediation chart
        if not remediation_df.empty and 'days_overdue' in remediation_df.columns:
            overdue_data = remediation_df[remediation_df['days_overdue'] > 0].copy()
            if not overdue_data.empty:
                # Sort by days overdue
                overdue_data = overdue_data.sort_values('days_overdue', ascending=False)
                fig = px.bar(
                    overdue_data,
                    x='name',
                    y='days_overdue',
                    color='severity',
                    title="Overdue Remediations",
                    labels={'name': 'Vulnerability', 'days_overdue': 'Days Overdue'},
                    color_discrete_map={
                        'Critical': '#d7191c',
                        'High': '#fdae61',
                        'Medium': '#ffffbf',
                        'Low': '#abd9e9'
                    }
                )
                fig.update_layout(
                    xaxis_title="Vulnerability",
                    yaxis_title="Days Overdue",
                    xaxis={'categoryorder':'total descending'},
                    height=400
                )
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.warning("No overdue remediation data available to display.")
        else:
            st.warning("No overdue remediation data available to display.")
        
        # Team assignments
        st.subheader("Remediation Assignments")
        
        team_filter = st.multiselect(
            "Filter by Team",
            options=sorted(remediation_df["assigned_to"].unique()),
            default=None
        )
        
        if team_filter:
            team_data = remediation_df[remediation_df["assigned_to"].isin(team_filter)]
        else:
            team_data = remediation_df
        
        # Group by team and severity
        team_severity = team_data.groupby(['assigned_to', 'severity']).size().reset_index(name='count')
        
        fig = px.bar(
            team_severity,
            x='assigned_to',
            y='count',
            color='severity',
            title="Remediation Assignments by Team and Severity",
            labels={'assigned_to': 'Team', 'count': 'Number of Vulnerabilities', 'severity': 'Severity'},
            color_discrete_map={
                'Critical': '#d7191c',
                'High': '#fdae61',
                'Medium': '#ffffbf',
                'Low': '#abd9e9'
            }
        )
        
        fig.update_layout(
            xaxis_title="Team",
            yaxis_title="Number of Vulnerabilities",
            height=400
        )
        
        st.plotly_chart(fig, use_container_width=True)
